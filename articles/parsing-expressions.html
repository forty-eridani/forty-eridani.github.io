<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Article about parsing expressions" />
    <title>Parsing Expressions</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="stylesheet" href="/css/common.css" />

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&family=Merriweather:ital,opsz,wght@0,18..144,300..900;1,18..144,300..900&family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap"
      rel="stylesheet"
    />

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/atom-one-light.min.css"
    />
    <script type="module">
      import hljs from "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/es/highlight.min.js";
      import py from "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/es/languages/python.min.js";
      import plaintext from "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/es/languages/plaintext.min.js";

      hljs.registerLanguage("python", py);
      hljs.registerLanguage("plaintext", plaintext);
      hljs.highlightAll();
    </script>

    <script
      id="MathJax-script"
      async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    ></script>
  </head>
  <body>
    <div class="navbar">
      <div class="nav-container-left">
        <a href="/" class="navigation" aria-label="Visit the homepage"
          >Nolan Thwaits</a
        >
      </div>
      <div class="nav-container-right">
        <a
          href="/about.html"
          class="navigation"
          aria-label="Visit the about page"
          >About</a
        >
        <a
          href="/contact.html"
          class="navigation"
          aria-label="Visit the contact me page"
          >Contact</a
        >
      </div>
    </div>

    <div class="page-title">
      <h1 class="">Parsing Expressions</h1>
      <p>Unpublished</p>
      <hr class="line" />
    </div>

    <div class="article-container">
      <div class="simple-article-text">
        <h2 class="section-header">Introduction</h2>
        <p class="paragraph">
          Since we were young lads, we have all known how to evaluate simple
          expressions in our heads like \( 2 + 2 \) or \( 10 / 5 \), but has it
          ever occurred to you how your calculator performs such operations? It
          seems trivial at first; one could write a program to consume a number,
          then the operator, then the other number and perform the operation on
          the two numbers dictated by the operator previously consumed. This
          solution however does not generalize to other valid expressions.
          Instead of explaining why it doesn't, I encourage you to come up with
          a general expression solving algorithm that can compute \( 15 / (2 +
          7) + 8 \). Isn't quite so easy now is it? There are quite a few
          algorithms for solving this problem (in fact one of my favorite
          algorithms--the shunting yard algorithm--was designed to solve this
          very problem), but for our purposes we will solve this using arguably
          the simplest method: recursive descent.
        </p>
        <p class="paragraph">
          Recursive descent may sound like a very complex algorithm, but at its
          heart it is an extremely simple, extremely powerful algorithm which
          implements recursion to "descend" into expression, solving highest
          precedence operations first and ascending once that has been computed.
          In fact, this algorithm is so powerful I used it to parse
          <a
            href="https://github.com/forty-eridani/custom-lang"
            class="hyperlink"
            aria-label="A link to the source code of my own programming language"
            >my own programming language</a
          >. What introduced me to this concept was an incredible book by Robert
          Nystrom titled
          <a
            href="https://craftinginterpreters.com/"
            aria-label="A link to the book Crafting Interpreters"
            class="hyperlink"
            >Crafting Interpreters</a
          >
          of which I owe a debt of gratitude to and a book you should definitely
          read if you have any interest in creating your own programming
          language. Anywho, we are not going to get straight away to parsing the
          expressions because it's quite difficult and inefficient to write a
          parser that understands raw text (and hurts my object-oriented soul),
          so instead let us begin with
        </p>

        <h2 class="section-header">Tokenizing the Input</h2>

        <p class="paragraph">
          To begin, let's simply enumerate the tokens we would like to have. We
          would like the addition operator \(+\), subtraction operator \(-\),
          division operator \(/\), and the multiplication operator \(*\). The
          enumerated names will not be of the operation they perform (addition,
          subtraction, etc), rather the names will represent the symbol itself
          since the tokenizer has no knowledge of their function, and in a real
          programming language, a symbol may have multiple jobs. We also need to
          enumerate for tokens for numbers, opening and closing parenthesis, as
          well as an end token to help the parser know when its job is done
        </p>

        <pre><code class="language-python">
from enum import Enum

class TokenType(Enum):
    PLUS = 0
    HYPHEN = 1
    STAR = 2
    SLASH = 3
    NUMBER = 4
    OPEN_PAREN = 5
    CLOSED_PAREN = 6
    END = 7
        </code></pre>

        <p class="paragraph">
          With our enumeration out of the way, we can move onto deciding how we
          should represent a token. This doesn't have to be complicated at all,
          there just has to be an object containing both the type of the token
          and the numerical value if the token happens to be a number. We could
          write our own class for this, but that seems too little state to
          encapsulate in a class and by default class string representations are
          quite ugly. Instead, we will simply use a tuple to hold the type of
          the token as well as its value if it's a number.
        </p>

        <p class="paragraph">
          There are likely more clever ways to tokenize a string in python,
          however I am no expert in python and using a less python specific
          method to tokenize will generalize to other programming languages. To
          start, let's simply iterate over the string and push the tokens
          corresponding to the characters of the string to an array of tokens.
          For now, let's start with operators
        </p>

        <pre><code class="language-python">
def tokenize(src):
  cur_index = 0
  tokens = []

  while cur_index &lt; len(src):
      if src[cur_index] == '+':
          tokens.append((TokenType.PLUS, 0))
          cur_index += 1
      elif src[cur_index] == '-':
          tokens.append((TokenType.HYPHEN, 0))
          cur_index += 1
      elif src[cur_index] == '*':
          tokens.append((TokenType.STAR, 0))
          cur_index += 1
      elif src[cur_index] == '/':
          tokens.append((TokenType.SLASH, 0))
          cur_index += 1
      elif src[cur_index] == '&#40;':
          tokens.append((TokenType.OPEN_PAREN, 0))
          cur_index += 1
      elif src[cur_index] == '&#41;':
          tokens.append((TokenType.CLOSED_PAREN, 0))
          cur_index += 1
        </code></pre>

        <p class="paragraph">
          Tokenizing numbers is slightly more complicated. We will only bother
          with integers in our parser in order to simplify things a little,
          though when the expression is evaluated we will keep the decimal to
          maintain precision in the answer. We will take the first index of the
          numbers and increment cur_index until we have reached the end of the
          number in the string. We can slice this section of the string and
          using python type conversions to turn it into an integer
        </p>

        <pre><code class="language-python">
def tokenize(src):
  # Other stuff ...

  while cur_index &lt; len(src):
     # Other stuff ...

      elif src[cur_index].isnumeric():
        start = cur_index

        while src[cur_index].isnumeric():
          cur_index += 1

        tokens.append((TokenType.NUMBER, int(src[start:cur_index])))
        </code></pre>

        <p class="paragraph">
          Now all that's left to do is increment cur_index when a space
          character is encountered, some very basic error handling, and return
          the list of tokens
        </p>

        <pre><code class="language-python">
def tokenize(src):
  # Other stuff ...

  while cur_index &lt; len(src):
     # Other stuff ...

    elif src[cur_index] == ' ':
      cur_index += 1
    else:
      raise Exception(f"Unknown character '{src[cur_index]}'.")

  return tokens
        </code></pre>

        <p class="paragraph">
          And there we have it! A very simple function that takes a raw string
          as input and spits out tokens. To test it out, let's write a simple
          mathematical expression and have our little tokenizer, well, tokenize
          that expression
        </p>

        <pre><code class="language-python">
print(tokenize("2 + 2 / (4 - 8)"))
        </code></pre>

        <p class="paragraph">And it should output something like</p>

        <pre><code class="language-plaintext">
[(&lt;TokenType.NUMBER: 4&gt;, 2), (&lt;TokenType.PLUS: 0&gt;, 0), (&lt;TokenType.NUMBER: 4&gt;, 2), 
(&lt;TokenType.SLASH: 3&gt;, 0), (&lt;TokenType.OPEN_PAREN: 5&gt;, 0), (&lt;TokenType.NUMBER: 4&gt;, 4), 
(&lt;TokenType.HYPHEN: 1&gt;, 0), (&lt;TokenType.NUMBER: 4&gt;, 8), (&lt;TokenType.CLOSED_PAREN: 6&gt;, 0)]
        </code></pre>

        <p class="paragraph">
          Perfect! You may think we can move straight onto parsing this
          tokenized expression, but before we can do that we must understand
        </p>

        <h2 class="section-header">Reverse Polish Notation</h2>

        <p class="paragraph">
          You may be wondering what Reverse Polish Notation is, and it has a
          quite an odd named considering the prevalence of the notation. To
          understand why, let's take a quick detour to learn the grammar and
          history of polish notation.
        </p>

        <p class="paragraph">
          Our typical representation of mathematical operations like addition
          and subtraction are what is called <em>infix</em>. This means the
          operators are fixed between the operands. I don't think many of us
          question this method of representing expressions. There are a few
          problems with this however. First of all, we have to assign precedence
          arbitrarily to certain operators meaning their result must be computed
          before the rest of the expression can be evaluated. If you want to
          perform an operation of high precedence where one of the operands is
          its own expression involving operators of lower precedence, you are
          forced to used parenthesis. This is a major pain that a specific
          Polish logician of the name Jan Łukasiewicz really wanted to solve.
        </p>

        <p class="paragraph">
          The idea he came up with is quite simple really, it merely involved
          moving the operators from the middle of the operators to the front. As
          you could probably guess, this is a <em>prefix</em> notation instead
          of an infix one. To get an idea of how this works, let's look at a
          simple expression \( 2 + 2 \). If we were to write this in Polish
          notation it would look something like \( + \hspace{5px} 2 \hspace{5px}
          2 \). Let's look at an even more complex expression, like \( 1 - 2 + 3
          \). Before we write the Polish notation for this expression, we have
          to understand something real quick. With most infix operators, the
          left side is evaluated before the right side meaning it has
          <em>left associativity</em>. We can represent this by using
          parenthesis to make explicit in what order the expression is
          evaluated. Both multiplication and addition have the associative
          property meaning that \( (1 + 2) + 3 = 1 + (2 + 3) \), but when we are
          dealing with operators of the same precedence where the associativity
          can change the value of the expression, we typically evaluated the
          left side as an operand to the rightmost operator. For example, \( 1 -
          2 + 3 \) is typically evaluated as \( (1 - 2) + 3 \). If we evaluated
          the right side first, we would get \( 1 - (2 + 3) \) which gives us a
          completely different answer. A huge advantage of Polish notation is
          that that associativity isn't implicit, rather it is made clear in the
          expression. If we turned this expression into Polish notation, it
          would appear as \( + \hspace{5px} - \hspace{5px} 1 \hspace{5px} 2
          \hspace{5px} 3 \). To understand the expression, it helps to evaluate
          operators right to left, so our first subexpression is \( -
          \hspace{5px} 1 \hspace{5px} 2 \) which translates the infix expression
          \( 1 - 2 \). The difference is \( -1 \), and we can stick it right
          back in our original expression yielding us \( + \hspace{5px} (-1)
          \hspace{5px} 3 \). Now we can simply evaluate this as \( -1 + 3 = 2\).
          Notice how the associativity is encoded explicitly within the
          notation? This makes the notation extremely unambiguous; no need for
          order of operation or explicitly defining associativity beyond the
          order an operator evaluates just two operands, which makes it quite
          easy to write a computer program for.
        </p>

        <p class="paragraph">
          You may have noticed the title of this section is
          <em>reverse</em> Polish notation, and as the name implies, it's simply
          Polish notation, just backwards. Instead of \( + \hspace{5px} 2
          \hspace{5px} 2 \), we would write \( 2 \hspace{5px} 2 \hspace{5px} +
          \). The advantage of this method is that we can evaluate this very
          simply with a data structure known as a stack. A stack is a data
          structure meant to contain individual elements. Elements can only be
          placed at the end of the stack in a process known as <em>pushing</em>.
          Elements can also only be retrieved from the end of stack, and this
          retrieval is known as <em>popping</em>. This makes the stack a LIFO
          (short for Last In First Out) data structure, or the last element
          pushed in (Last In) the stack is first element retrieved (First Out).
          The reason <em>Reverse</em> Polish Notation is so powerful is because
          we can process it with a stack. Let's use the previous example of \( 2
          \hspace{5px} 2 \hspace{5px} + \). First, we push \(2\) to the stack,
          next we push the other \(2\) to the stand, but now we encounter the
          operator \(+\). All we have to do here is pop both of our numbers from
          the stack and apply the corresponding operator, in this case \(+\), to
          the popped operands, and finally push the result on the stack. At the
          end we simply take the only remaining number on the stack which is the
          answer to the expression. To prove this works with larger expressions,
          let's take a look at the example we used previously (just in reverse
          polish notation), \( 1 \hspace{5px} 2 \hspace{5px} - \hspace{5px} 3 +
          \hspace{5px} \). First we push \(1\) and \(2\) to the stack. We then
          encounter the \(-\) operator. This is where we have to be a little
          careful. Because the notation is in reverse, the second number we
          popped on the stack is going to be the <em>first</em> number in the
          expression. In our case, the last number we pushed to the stack was
          \(2\), but \(2\) is the right operand in the expression and to get the
          left one we must pop off the stack. Now that we have this, we can push
          \(-1\) to the stack. Next, we encounter \(3\) in our expression and so
          we push it onto the stack. Finally, we run into the \(+\) operator
          which means we pop \(-1\) and \(3\) off the stack, add them, and push
          the sum, \(2\) back on the stack. Since that's the end of the
          expression, \(2\) is the answer to the expression \( 1 \hspace{5px} 2
          \hspace{5px} - \hspace{5px} 3 + \hspace{5px} \). Here is my crude
          animation to demonstrate this concept
        </p>

        <div class="image-container">
          <img
            src="/media/video/rpn-animation.gif"
            width="256px"
            height="256px"
            alt="Gif demonstrating how Reverse Polish Notation is evaluated"
          />
        </div>

        <p class="paragraph">
          Now we have to finally deal with the job of actually programming it.
          We could come up for a whole new representation of the numbers and
          operators, but since we already have a perfectly usable method of
          representation via our tokens, so all our evaluator will do is process
          an array of tokens arranged in Reverse Polish Notation. Let's start by
          creating a method to turn an array of tokens to a single numerical
          answer
        </p>

        <pre><code class="language-python">
def evaluate(tokens):
  stack = []

  for token in tokens:
    if token[0] == TokenType.NUMBER:
      # Appending is pushing to python lists
      stack.append(token[1])
    elif token[0] == TokenType.PLUS:
      # The left operand is the first one pushed so is the last one popped
      b = stack.pop()
      a = stack.pop()
      stack.push(a + b)
    elif token[0] == TokenType.HYPHEN:
      # The left operand is the first one pushed so is the last one popped
      b = stack.pop()
      a = stack.pop()
      stack.push(a - b)
    elif token[0] == TokenType.STAR:
      # The left operand is the first one pushed so is the last one popped
      b = stack.pop()
      a = stack.pop()
      stack.push(a * b)
    elif token[0] == TokenType.SLASH:
      # The left operand is the first one pushed so is the last one popped
      b = stack.pop()
      a = stack.pop()
      stack.push(a / b)
  
  return stack.pop()
        </code></pre>

        <p class="paragraph">
          With this out of the way we only have one task to complete: our
          parser. Since the evaluator uses the same kind of tokens that our
          tokenizer spits out, all the parser has to do is rearrange the tokens
          from infix to Reverse Polish Notation without changing the
          representation of the numbers and operators. Isolating the problem and
          solving it in its simplest form is a good problem solving technique in
          general, so reusing and keeping the scope of the parser small will
          adhere to this principle thus allowing us to solving the problem in
          its essence.
        </p>

        <h2 class="section-header">Parsing (finally)</h2>

        <p class="paragraph">
          We have finally arrived at the true point of this article: parsing.
          With all the scaffolding complete, all we need is a parser to bridge
          the gap from the raw tokens to something legible to the evaluator, and
          to do this we get to learn a new algorithm: recursive descent! For
          those of you not too familiar with recursion, I recommend taking a
          peek at
          <a
            href="https://developer.mozilla.org/en-US/docs/Glossary/Recursion"
            class="hyperlink"
            aria-label="A link to a Mozilla article on recursion"
            >this article</a
          >
          from Mozilla (it is in javascript however, but the concept is
          universal).
        </p>

        <p class="paragraph">
          The idea of recursive descent is remarkably similar to how we humans
          solve these infix expressions. The algorithm traverses the expression,
          dealing with the highest precedence operations before moving on to
          process lower-precedence operations (often involving operands that
          include those higher-precedence operations). For example, let's take a
          peek at the expression \( 1 - 2 * 3 \). If we simply kept every
          operation left associative, we would end up with \((1 - 2) * 3\) which
          is not what we want. Instead we want our algorithm to handle \( 2 * 3
          \) as its own subexpression before moving on to the \( - \) operator.
          To do this, we exploit the call stack (in fact, most algorithms
          solving this problem use stacks, whether implicitly through calling
          functions or explicitly using a stack with an iterative algorithm like
          the shunting yard algorithm). Let's just imagine 3 levels of the call
          stack to solve this expression. The first layer is going to handle the
          lowest precedence operators \(+\) and \(-\). The second layer is going
          to handle the higher precedence operators \(*\) and \(/\), and the
          very highest level of precedence are the numbers themselves as there
          isn't anything to process within a number. In our expression we first
          hit \(1\) which doesn't match the operators in the first two
          precedence levels. Once \(1\) is pushed to the stack, our index is
          incremented so the current character is \(-\), the function exits, and
          we return to the second level of precedence which processes \(*\) and
          \(/\). Of course, \(-\) doesn't match either \(*\) or \(/\), so we
          exit and return to the lowest level of precedence involving the
          operators \(+\) and \(-\) which finally <em>can</em> be processed by
          the current level of precedence. When dealing with reverse polish
          notation, we have to process both operands before pushing the operator
          to the stack, so we store \(-\) and move on to the right operand. The
          first character encountered is \(2\), which the lowest precedence
          can't match, so once again it calls up to the second highest
          precedence function which also cannot handle it, so we call up at the
          very highest precedence-handling function which handles \(2\) by
          pushing it to the stack. Once again, the index is incremented and we
          encounter \(*\). Here is where the magic comes in. The function of
          second highest precedence is able to handle \(*\), so it goes and
          processes \(3\) just by calling up the precedence chain once again
          (which is only one call deep at this point) and pushes \(3\) to the
          stack. Now that both of the operands to the \(*\) operation have been
          pushed to the stack, we can finally push \(*\) to the stack. The
          function exits and returns to the lowest precedence which is now done
          processing the right operand, and so can push \(-\) to the stack.
          Isn't this absolutely gorgeous? By exploiting layers the call stack
          provides us, we can process higher precedence operands entirely before
          moving onto those of lower precedence. Even if there is no low
          precedence operation, by treating it has the left operand to some
          expected low precedence operations and then never computing a right
          operand, we can ensure expressions made up of entirely high precedence
          operations can be computed.
        </p>
      </div>
    </div>

    <div class="bottom"></div>
  </body>
</html>
